
# Programming from ground up 示例和练习答案 

## 在 x86-64 GNU/Linux 平台上完成

- 使用 uname -m 查看系统架构是32位或64位

- x86指令后缀意义：byte (8 bits), word (16bits), long (32bits), quadword (64bits), double quedword (128bits)

- 32位系统的系统调用分别使用以下寄存器存放参数：%eax, %ebx, %ecx, %edx

- 64位系统中系统调用编号存放在 %rax 中

- 64位系统中程序退出码存放在 %rdi 中

- 64位系统的系统调用表的各个编号与32位的系统调用表的编号是不同的，可以查看 ABI 表了解详情

- 64位系统的函数调用惯例是使用寄存器保存参数，而不是像32位那样在函数调用前将参数压入栈中

- 64位系统中用户级函数调用前6个参数分别使用下列寄存器存放参数: %rdi, %rsi, %rdx, %rcx, %r8 and %r9，内核接口前6个参数使用 %rdi, %rsi, %rdx, %r10, %r8 和 %r9 存放参数，然后剩下的参数从右到左依次压栈

- 64位系统中，调用可变数量参数的函数时，需要将参数数量保存在寄存器 %al 中

- 64位系统中函数返回值存放在 %rax 中

- .data 和 .bss 段中定义变量符号，在 .text 代码段中直接使用时会替换成该变量的值，而在前加$符后使用会替换成该变量符号的内存地址。（示例：address.s）

- brk系统调用，传0时返回当前最大的可用的heap地址，传正值增大heap区(即C库函数malloc)，传负值减小heap区(即C库函数free)

- 函数调用前必须注意保存寄存器中后续程序要用到值(push)，函数调用后恢复其值到寄存器中(pop)；尤其是调用库函数等外部库函数，因为我们不知道该函数会覆盖哪些寄存器的值

- divq 除法运算须使用特定的寄存器 除数->div指令指定的寄存器, 被除数->%rax, 商->%rax, 余数->%rdx

