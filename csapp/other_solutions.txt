
Solutions to Problem:

2.18:
32-bit Two's complement
0x1b8		00000001 10101000 1*2^8 + 11*2^4 + 8 = 256 + 176 + 8 = 440
0x14		1*2^4 + 4 = 20
0xfffffe58	-0x1a8 = -256 + -160 + -8 = -424
0xfffffe74 	-0x18c = -256 + -128 + -12 = -396
0x44		4*16 + 4 = 68
0xfffffec8	-0x138 = -256 + -48 + -8 = -312
0x10		16
0xc 		12
0xfffffeec	-0x114 = -256 + -16 + -4 = -276
0x20		32

2.19:
-8	1000	8
-3	1101	13
-2	1110	14
-1	1111	15
0	0000	0
5	0101	5

2.21:
unsigned	1
int 		1
unsigned	0
int 		1
unsigned	0

2.23:
fun1(w)			fun2(2)
00000076		00000076
00000021		00000021
000000c9		ffffffc9
00000087		ffffff87

fun1() performs logical left shift for 3 bytes and logical right shift for 3 bytes.

fun2() performs type cast from unsigned to int, performs logical left shift for 3 bytes and arithmetical right shift for 3 bytes.

2.24:
0	0
2	2
1	-7->9->1
3	-5->11->3
7	-1->15->7

2.25:
for variable "length" have data type unsigned, subtract "length" with 1, cause a overflow, make the "length" equals 0xFFFFFFFF, that is 4294967295 in decimal.

2.72:
A: 
when operate with an unsigned and an int, the C compiler
will see the result as an unsigned type.

B:
if (maxbytes - (int)sizeof(val) >= 0)

2.76:
A: (x << 4) + x
B: -(x << 3) + x
C: (x << 6) - (x << 2)
D: -(x << 7) + (x << 4)

3.1:
0x100
0xAB
0x108
0xFF
0xAB
0x11
0x13
0xFF
0x11

3.2:
1 movl %eax, (%esp)
2 movw (%eax), %dx
3 movb $0xFF, %bl
4 movb (%esp,%edx,4), %dh
5 pushb $0xFF
6 movw %dx, (%eax)
7 popl %edi

3.3:
1 movb $0xF, (%bl)		# %bl can not be pointer, too short
2 movl %ax, (%esp) 		# should use movw
3 movw (%eax),4(%esp)	# two oprands can not be two address
4 movb %ah,%sh			# no register named %sh
5 movl %eax,$0x123		# can not mov the value of %eax to an Immediate value
6 movl %eax,%dx			# should use movw
7 movb %si, 8(%ebp)		# should use movw

3.4:
movsbl %al (%edx)
movsbl %al (%edx)
movzbl %al (%edx)
movb %al (%edx)
movb %al (%edx)
movl %eax (%edx)

3.5:
void decode1(int *xp, int *yp, int *zp)
{
    int b = *yp
    int s = *zp
    int a = *xp

    *yp = a;
    *zp = b;
    *xp = s;
}


3.6:
x+6
x+y
x+(y*4)
x+(y*8)+7
(y*4)+10
x+(y*2)+9

3.7:
0x100   0x100
0x104   0xA8
0x10c   0x110
0x108   0x14
%ecx    0x0
%eax    0xFD

3.8:
SHL $2, %eax 
SAR %ecx, %eax

3.9:
t1 = x ^ y;
t2 = t1 >> 3;
t3 = ~t2;
t4 = t3 - z;

3.10:
A: set all bit of register as zero
B: movl $0, %edx
C: XOR use only one register, that is 4 bytes; MOV use one register and one word
in memory, totally use 8 bytes;

3.11:
movl 8(%ebp), %eax  // Put x to %eax
xorl %edx, %edx     // Set %edx to 0
divl 12(%ebp)       // Divide by y
movl %eax, 4(%esp)  // Store x / y
movl %edx, (%esp)   // Store x % y

3.12:
The data type of num_t is:
struct {
    int a, 
    int b
}

algorithm:
function test(dest, x, y) {
    b = x * b;
    long la = x * a;
    long lb = b;
    lb = lb << 32;
    la = la + lb;
    return la;
}


3.13:
int     a < b
short   a >= b
unsigned char  a < b
int a != b

3.14:
int     a != 0
short   a == 0
char    a > 0
unsigned short  a > 0

3.15:
A: 8048291 + 05 = 8048296
B: 8048359 + e7 = 8048440
C: 8048391 - 12 = 804837f
D: Two's complement form ffffffe0 is decimal number 32,  80482c4 + 32 = 80482f6
E: ff 25 fc 9f 04 08, 0xff25 is the instruction jmp*, 0x8049ffc is the memory address which stored the jump target address

3.16:
A:
void cond(int a, int *p) {
    if (p == 0)
        goto done;

    if (a <= 0)
        goto done;

    *p += a;

    done:
}

B: Because of C code's conditional statement has two child statment with AND
logical condition, it is two condition

3.17:
A:
gotodiff(int x, int y) {
    int result;
    if (x < y)
        goto true;
    result = x - y;
    goto done;
true:
    result = y - x;
done:
    return result;
}

B:
The reson is Less operation , less instruction, less time, such as if (!test-expr) is one
more operation than if (test-expr).

3.18:

int test(int x, int y) {
    int val = x * y;
    if (x >= -3) {
        if (x > 2) {
            x = y - x;
        } else {
            x = y ^ x;
        }
    } else if (x <= y)
        val = x + y;
}

3.20:

int dw_loop(int x, int y, int n) {
    do {
        x += n;             // body-statement start
        y *= n;
        n--;                // body-statement end
    } while ((n > 0) && (y < n));   // test-expr
    
    return x;
}


// x at %ebp+8, y at %ebp+12, n at %ebp+16
    movl 8(%ebp), %eax      // Put argument value to register
    movl 12(%ebp), %ecx
    movl 16(%ebp), %edx
.L2:
    addl %edx, %eax         // body-statement start, x += n
    imull %edx, %ecx        // y *= n
    subl $1, %edx           // body-statement end, ++n
    testl %edx, %edx        // test-expr, check whether n <= 0
    jle .L5
    cmpl %edx, %ecx         // test-expr, check whether y < n
    jl .L2
.L5
            // return x

A:
Register        Variable        Initally
%eax            x               Argument value
%ecx            y               Argument value
%edx            n               Argument value

3.21:

int loop_while(int a, int b) {
    int c = a + b;
    int result = 1;

    while (a < b) {
        result *= c;   
        ++a;
        ++c;
    }

    return result;
}
}

3.22:

int fun_a(unsigned x) {
    int val = 0;
    while(a) {
        val ^= x;
        x >>= 1;
    }
    return val & 1;
}

将x的最低位从低到高依次与每一个位做异或运算，直到最高的有效位,
返回最终的运算结果

3.23:

A:

int fun_b(unsigned x) {
    int val = 0;
    int i;
    for (i = 0; i != 32; i++) {
        val = (val <<= 1) | (x & 1)
        x >>= 1;
    }
    return val;
}

B:

This function reverse x's bits, transform lower bits to higher bits.


3.25:

A: (31 - 16) * 2 = 30
B: (16 + 30) = 46


从switch语句这一节，开始看 CSAPP-3e


3.30:
A: The value of case lable is the address of block that start with case label.
B: .L2 .L5 and .L7

3.31:
void switcher(long a, long b, long c, long *dest)
{
    long val;
    switch(a) {
    case 5: /* Case A */
        c = a ^ 15;
        /* Fall through */

    case 0: /* Case B */
        val = c + 112;
        break;

    case 7: /* Case C */
    case 2: /* Case D */
        val = (a + c) * 4;
        break;

    case 4: /* Case E */
        val = b;
        break;

    default:
        val = a;
    }
    *dest = val;
}


3.33:
(int a, char b, long *u, char *v)

3.34:
A: a0 ~ a6
B: a7, a8
C: Because there are only six callee-saved registers, and 
    the number of local values may exceed six.

3.35:


A: the value of parameter x

B:
long rfun(unsigned long x) {
    if (x = 0)
        return 0;
    unsigned long nx = x / 4;
    long rx = rfun(nx);
    return x + nx;
}

3.36:
Array   Element size    Total size  Start address   Element i
P       4               20          XP              Xp + 4 * i
Q       2               4           XQ              Xq + 2 * i
R       8               72          XR              Xr + 8 * i
S       8               80          XS              Xs + 8 * i
T       8               16          Xt              XT + 8 * i

3.37:
address of P in rdx, value of i in rcx.

Expression  Type        Value                   Assembly code
P[1]        short       M[Xp + 2i]              movw (%rdx, %rcx, 2), %ax
P + 3 + i   short *     Xp + 6 + 2i             leaq 6(%rdx, %rcx, 2), %rax
P[i*6 - 5]  short       M[Xp + 12i - 10]        movw -10(%rdx, %rcx, 12), %ax
P[2]        short       M[Xp + 4]               movw 4(%rdx), %ax
&P[i + 2]   short *     Xp + 2i + 4             leaq 4(%rdx, %rcx, 2), %rax

3.38:
From the assembly code, we can get follow result:
P[i][j] = XP + 8 * (7i + j)
Q[j][i] = XQ + 8 * (5j + i)

And because of 
P[i][j] = XP + 8 * (i*M + j)
Q[j][i] = XQ + 8 * (j*N + i)

So we get:
M is 7, and N is 5.

3.39:
From question, we have:
C = R = N = 16

Aptr = &A[i][0] = XA + 4(C*i + 0) = XA + 64i
Bptr = &B[0][k] = XB + 4(C*0 + k) = XB + 4k
Bend = &B[N][K] = XB + 4(C*N + k) = XB + 4*16*16 + 4*k = XB + 1024 + 4k

3.40:
solution in 3.40.c file.

3.41:
A: 
P       0
s.x     8
s.y     10
next    12

B:
20

C:
void st_init(struct test *st) {
    st->s.y = st->s.x;
    st->p   = &(st->s.y)
    st->next= st
}

3.42:
A:
short test(struct ACE *ptr) {
    short i = 1;

    do {
        i *= ptr->v;
        ptr = ptr->p;
    } while (ptr);

    return i;
}

B:
ACE has a short intger 'v' and a pointer 'p' which pointed to
another ACE.
function test compute the product of ACE's v and check the ACE's
pointer p, if p not NULL, go to next ACE and compute the product,
and so on.


3.43:
expr        type    Code
up->t1.v    short   movw 8(%rdi), %ax
                    movw %ax, (%rsi)

&up->t1.w   char*   leaq 10(%rdi), %rax
                    movq %rax, (%rsi)

up->t2.a    array   leaq 12(%rdi), %rax
                    movq %rax, (%rsi)

up->t2.a[up->t1.u]    int   
                    movq (%rdi), %rcx
                    movl 12(%rdi, %rcx, 4), %eax
                    movl %rax, (%rsi)

*up->t2.p   char    movq 20(%rdi), %rax
                    movb (%rax), %cl
                    movb %cl, (%rsi)

3.44:
A: offset: 0, 4, 8, 16; total size: 24; 
start address of structure is multiply of 8

B: offset: 0, 8, 16, 24; total size: 32; 
start address of structure is multiply of 8

C: offset: 0, 8; total size 24;
start address of structure is multiply of 8

D: offset: 0, 16; total size 32;
start address of structure is multiply of 8

E: offset: 0, 64; total size 88;
start address of structure is multiply of 8

3.45:
struct {
    int *a;
    float b;
    char c;
    short d;
    long e;
    double f;
    int g;
    char *h;
} rec

A: offset: 0, 8, 12, 14, 16, 24, 32, 40
B: total size is 48 bytes
C: 
struct {
    int *a;
    long e;
    double f;
    char *h;
    float b;
    int g;
    short d;
    char c;
} rec
offset: 0, 8, 16, 24, 32, 36, 40, 42; total size is 43;

2021-03-09 看到295页
2021-03-19 看到301页
2021-03-20 看到312页

