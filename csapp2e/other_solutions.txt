
Solutions to Problem:

2.18:
32-bit Two's complement
0x1b8		00000001 10101000 1*2^8 + 11*2^4 + 8 = 256 + 176 + 8 = 440
0x14		1*2^4 + 4 = 20
0xfffffe58	-0x1a8 = -256 + -160 + -8 = -424
0xfffffe74 	-0x18c = -256 + -128 + -12 = -396
0x44		4*16 + 4 = 68
0xfffffec8	-0x138 = -256 + -48 + -8 = -312
0x10		16
0xc 		12
0xfffffeec	-0x114 = -256 + -16 + -4 = -276
0x20		32

2.19:
-8	1000	8
-3	1101	13
-2	1110	14
-1	1111	15
0	0000	0
5	0101	5

2.21:
unsigned	1
int 		1
unsigned	0
int 		1
unsigned	0

2.23:
fun1(w)			fun2(2)
00000076		00000076
00000021		00000021
000000c9		ffffffc9
00000087		ffffff87

fun1() performs logical left shift for 3 bytes and logical right shift for 3 bytes.

fun2() performs type cast from unsigned to int, performs logical left shift for 3 bytes and arithmetical right shift for 3 bytes.

2.24:
0	0
2	2
1	-7->9->1
3	-5->11->3
7	-1->15->7

2.25:
for variable "length" have data type unsigned, subtract "length" with 1, cause a overflow, make the "length" equals 0xFFFFFFFF, that is 4294967295 in decimal.

2.72:
A: 
when operate with an unsigned and an int, the C compiler
will see the result as an unsigned type.

B:
if (maxbytes - (int)sizeof(val) >= 0)

2.76:
A: (x << 4) + x
B: -(x << 3) + x
C: (x << 6) - (x << 2)
D: -(x << 7) + (x << 4)

3.1:
0x100
0xAB
0x108
0xFF
0xAB
0x11
0x13
0xFF
0x11

3.2:
1 movl %eax, (%esp)
2 movw (%eax), %dx
3 movb $0xFF, %bl
4 movb (%esp,%edx,4), %dh
5 pushb $0xFF
6 movw %dx, (%eax)
7 popl %edi

3.3:
1 movb $0xF, (%bl)		# %bl can not be pointer, too short
2 movl %ax, (%esp) 		# should use movw
3 movw (%eax),4(%esp)	# two oprands can not be two address
4 movb %ah,%sh			# no register named %sh
5 movl %eax,$0x123		# can not mov the value of %eax to an Immediate value
6 movl %eax,%dx			# should use movw
7 movb %si, 8(%ebp)		# should use movw

3.4:
movsbl %al (%edx)
movsbl %al (%edx)
movzbl %al (%edx)
movb %al (%edx)
movb %al (%edx)
movl %eax (%edx)

3.5:
void decode1(int *xp, int *yp, int *zp)
{
    int b = *yp
    int s = *zp
    int a = *xp

    *yp = a;
    *zp = b;
    *xp = s;
}


3.6:
x+6
x+y
x+(y*4)
x+(y*8)+7
(y*4)+10
x+(y*2)+9

3.7:
0x100   0x100
0x104   0xFD
0x10c   0x110
0x108   0x14
%ecx    0x0
%eax    0xFD

3.8:
SHL %eax, $2
SAR %eax, %ecx

读到第 216 页，先跳过第二章

